= Crystal Lang Explorations -- Async State Sharing
:source-highlighter: prettify
:source-language: crystal
Bill Tihen (Crystal 0.32.1)
Version 0.0.1
:sectnums:
:toc:
:toclevels: 4
:toc-title: Contents

:description: Exploring Crystal's Features
:keywords: Crystal Language
:imagesdir: ./images


*link:index.html[Start Page]*

== Channel Callbacks

When we no longer need to communicate with a `User` we are keeping the channel open - which won't allow the garbage collector to remove unused instances.

Ideally, we will close the channel, remove the user from the chat registry and only close the chat after all messages are delivered.

.src/channel_callbacks/user.cr
[source,linenums]
----
class User
  getter channel : Channel(String)
  private getter name : String, email : String, sign_out : Channel(User)

  def initialize(@name, @email, @status)
    @channel = Channel(String).new(2)
    listen_for_messages
  end

  def to_s
    "#{name} <#{email}>"
  end

  private def listen_for_messages
    spawn do
      loop do
        message = channel.receive?
        break     if message.nil?

        puts "To: #{to_s} -- #{message}"
      end
      puts "#{to_s} -- CLOSING"
      sign_out.send(self)   # loop ends when channels closes - send close status
    end
  end
end
----

.src/channel_callbacks/main.cr
[source,linenums]
----
require "./user"

# create users
status = Channel(User).new

user_1 = User.new(name: "first",  email: "first@example.ch", status: status)
user_2 = User.new(name: "second", email: "second@example.ch", status: status)

puts "REAL-TIME - START"
spawn user_1.channel.send("ASYNC sent 1st!")
user_1.channel.send("REAL-TIME sent 2nd!")
spawn user_1.channel.send("ASYNC sent 3th!")
user_2.channel.send("REAL-TIME sent 4th!")
spawn user_2.channel.send("ASYNC sent 5th!")
user_1.channel.send("REAL-TIME sent 6th!")
puts "REAL-TIME - DONE"
user_1.channel.close
user_2.channel.close

2.times { status.receive }
----

Run with:
```bash
$ crystal src/channel_callbacks/main.cr
```

Now we can wait for all channels to close.

Below shows code that allows us to track users 'registered' in the `users` array (we remove users when they close their channel)

.src/channel_callbacks/main_stress.cr
[source,linenums]
----
require "./user"

module MainStress

  # make callback status channel
  status = Channel(User).new

  # make a large number of users
  users  = [] of User

  10000.times do |i|
    user = User.new(name: "user_#{i}", email: "user_#{i}@example.ch", status: status)
    users << user
  end

  # send lots of messages - async (for some reason async needs to be first)
  users.each do |receiver|
    spawn receiver.channel.send("ASYNC -- From: #{receiver.to_s} - with channel")
  end

  # send lots of messages - async (for some reason async needs to be first)
  users.each do |receiver|
    spawn receiver.channel.send("ASYNC -- From: #{receiver.to_s} - with channel")
  end

  # close asynchronously to allow messages to be delivered
  users.each do |receiver|
    spawn receiver.channel.close
  end

  # wait for all channels close - which 'unregisters' a user from `users`
  #######
  # we can also do this and 'unscribe' users when they close their channels
  # ideally this would also run within a listener (and not in a loop)
  while users.size > 0
    user   = status.receive?
    break if user.nil?

    users.delete(user)
    puts "CLOSED: #{user.to_s}"
  end
end
----

Run with:
```bash
$ crystal src/channel_callbacks/main_stress.cr
```

@stnluu_twitter
Fix for the stress testing is buffering when switching back and forth between sync and async.

*link:index.html[Start Page]*
