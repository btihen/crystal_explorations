= Crystal Lang Channel Callbacks
:source-highlighter: prettify
:source-language: crystal
Bill Tihen (Crystal 0.32.1)
Version 0.0.1
:sectnums:
:toc:
:toclevels: 4
:toc-title: Contents

:description: Exploring Crystal's Features
:keywords: Crystal Language
:imagesdir: ./images


*link:index.html[Start Page]*

Exploring & Learning Crystal Language with code examples and augment the documentation.

NOTE: This code does not focus on best practices, security or production ready code. +
The code is just good enough to demonstrate what is happening.

== Call-Back Channels

When we no longer need to communicate with a `User` we are keeping the channel open - which won't allow the garbage collector to remove unused instances.

Ideally, we will close the channels when we are done and we can even use that info to know if we can end our *main thread* (program).


@stnluu_twitter & @randiaz95 - I have two versions of using channels and fibers at: https://github.com/btihen/crystal_channels - It works pretty well. I next want to figure out how to create multiple TCP or windows (one for each user). I realized when doing the chat room - using one thread works well - but compiliing with multiple cores - outputting to one screen gets jumbled again. I'll happily learn more about multiple connections (I assume I need to use TCP sockets) - could I also use OS sockets?

who is doing the output to screen?
remember yesterday, we discussed about ideally, there's a "room" object that keeps track of all the users, and does the job of broadcasting the messageâ€“instead of each user keeping track of all the other users?
ideally, this "room" object should be the one doing the output to screen, aka only one fiber doing the output.


from @repomaa

```
.src/channel_callbacks/user.cr
[source]
----
class User
  getter channel : Channel(String)
  private getter name : String, email : String, status : Channel(Nil)

  def initialize(@name, @email, @status)
    @channel = Channel(String).new
    listen_for_messages
  end

  def to_s
    "#{name} <#{email}>"
  end

  private def listen_for_messages
    spawn do
      loop do
        message = channel.receive?
        break     if message.nil?

        puts "To: #{to_s} -- #{message}"
      end
      status.send(nil)   # loop ends when channels closes - send close status
    end
  end
end
----

.src/channel_callbacks/main.cr
[source]
----
require "./user"

# create users
status = Channel(Nil).new
user_1 = User.new(name: "first",  email: "first@example.ch", status: status)
user_2 = User.new(name: "second", email: "second@example.ch", status: status)

puts "REAL-TIME - START"
spawn user_1.channel.send("ASYNC sent 1st!")
user_1.channel.send("REAL-TIME sent 2nd!")
spawn user_1.channel.send("ASYNC sent 3th!")
user_2.channel.send("REAL-TIME sent 4th!")
spawn user_2.channel.send("ASYNC sent 5th!")
user_1.channel.send("REAL-TIME sent 6th!")
puts "REAL-TIME - DONE"
user_1.channel.close
user_2.channel.close

2.times { status.receive }
----

Run with:
```bash
$ crystal src/channel_callbacks/main.cr
```

Now we can wait for all channels to close.

Below shows code that allows us to track users 'registered' in the `users` array (we remove users when they close their channel)

.src/channel_callbacks/main_stress.cr
[source]
----
require "./user"

module MainStress

  # make callback status channel
  status = Channel(User).new

  # make a large number of users
  users  = [] of User

  10000.times do |i|
    user = User.new(name: "user_#{i}", email: "user_#{i}@example.ch", status: status)
    users << user
  end

  # send lots of messages - async (for some reason async needs to be first)
  users.each do |receiver|
    spawn receiver.channel.send("ASYNC -- From: #{receiver.to_s} - with channel")
  end

  # send lots of messages - async (for some reason async needs to be first)
  users.each do |receiver|
    spawn receiver.channel.send("ASYNC -- From: #{receiver.to_s} - with channel")
  end

  # close asynchronously to allow messages to be delivered
  users.each do |receiver|
    spawn receiver.channel.close
  end

  # wait for all channels close - which 'unregisters' a user from `users`
  #######
  # we can also do this and 'unscribe' users when they close their channels
  # ideally this would also run within a listener (and not in a loop)
  while users.size > 0
    user   = status.receive?
    break if user.nil?

    users.delete(user)
    puts "CLOSED: #{user.to_s}"
  end
end
----

*link:index.html[Start Page]*
