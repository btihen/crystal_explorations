= Crystal Lang Channel Callbacks
:source-highlighter: prettify
:source-language: crystal
Bill Tihen (Crystal 0.32.1)
Version 0.0.1
:sectnums:
:toc:
:toclevels: 4
:toc-title: Contents

:description: Exploring Crystal's Features
:keywords: Crystal Language
:imagesdir: ./images


*link:index.html[Start Page]*

Exploring & Learning Crystal Language with code examples and augment the documentation.

NOTE: This code does not focus on best practices, security or production ready code. +
The code is just good enough to demonstrate what is happening.

== Call-Back Channels

When we no longer need to communicate with a `User` we are keeping the channel open - which won't allow the garbage collector to remove unused instances.

Ideally, we will close the channels when we are done and we can even use that info to know if we can end our *main thread* (program).


@stnluu_twitter & @randiaz95 - I have two versions of using channels and fibers at: https://github.com/btihen/crystal_channels - It works pretty well. I next want to figure out how to create multiple TCP or windows (one for each user). I realized when doing the chat room - using one thread works well - but compiliing with multiple cores - outputting to one screen gets jumbled again. I'll happily learn more about multiple connections (I assume I need to use TCP sockets) - could I also use OS sockets?

who is doing the output to screen?
remember yesterday, we discussed about ideally, there's a "room" object that keeps track of all the users, and does the job of broadcasting the messageâ€“instead of each user keeping track of all the other users?
ideally, this "room" object should be the one doing the output to screen, aka only one fiber doing the output.


from @repomaa

```
class User
  getter channel : Channel(String)
  private getter name : String, email : String, status : Channel(Nil)

  def initialize(@name, @email, @status)
    @channel = Channel(String).new
    listen_for_messages
  end

  def to_s
    "#{name} <#{email}>"
  end

  private def listen_for_messages
    spawn do
      loop do
        message = channel.receive?
        break     if message.nil?

        puts "To: #{to_s} -- #{message}"
      end
      status.send(nil)  
    end
  end
end

# create users
status = Channel(Nil).new
user_1 = User.new(name: "first",  email: "first@example.ch", status: status)
user_2 = User.new(name: "second", email: "second@example.ch", status: status)

puts "REAL-TIME - START"
spawn user_1.channel.send("ASYNC sent 1st!")
user_1.channel.send("REAL-TIME sent 2nd!")
user_1.channel.send("REAL-TIME sent 3th!")
user_2.channel.send("REAL-TIME sent 4th!")
spawn user_2.channel.send("ASYNC sent 5th!")
user_1.channel.send("REAL-TIME sent 6th!")
puts "REAL-TIME - DONE"
user_1.channel.close
user_2.channel.close

2.times { status.receive }
```


*link:index.html[Start Page]*
