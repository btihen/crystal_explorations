@plambert nope, with a NamedTuple you always have to supply all of the fields. Maybe you should think about using a record instead?

@watzon
```
record Foo, id : Int32, name : String? = nil

foo = Foo.new(32)
# => Foo(id: 32, name: nil)
```
@watzon ooh. how is a record different from a struct?

It's just a simplified syntax for creating a Struct with a default initializer
also defines getters and some ways to copy it

You can also do
```
record Foo, name : String, id : Int32 do
  def do_something
  end
end
```

## Records

Records are a simplified way to create a Struct _(they have default initializer)._

**Record Definitions**
```
record Foo, id : Int32, name : String
# or
record(Foo, id : Int32, name : String)
```

Like structs, records can also have custom behaviors - defined with:
```
record(Foo, name : String, id : Int32) do
  def to_s
    puts "Foo: id: #{id}; name: #{name}"
  end
end
```

Records can be a flexible data structure (tuples and others require a fixed data structure - without `nil`s).

For example if you need a simple data structure that may or maynot have all the data you can define a record with the following parameters `name : String? = nil`
```
record Foo, id : Int32, name : String? = nil do
  def to_s
    puts "Foo: id: #{id}; name: #{name}"
  end
end
```

**Record Usage:**
Record assignment is done using:
```
foo1 = Foo.new(1)
# => Foo(id: 1, name: nil)
foo2 = Foo.new(2, "Bar")
# => Foo(id: 2, name: "Bar")
```

Record usage looks like:
```
puts "id: #{foo1.id}"
# => id: 1
puts "name: #{foo1.name}"
# => name:
puts foo1.to_s
# => Foo: id: 1; name:
puts "id: #{foo2.id}"
# => id: 2
puts "name: #{foo2.name}"
# => name: Bar
puts foo2.to_s
# => Foo: id: 2; name: Bar
```
