= Crystal Lang Concurrency
Bill Tihen - using Crystal 0.32.1
Version 0.0.1
:sectnums:
:toc:
:toclevels: 4
:toc-title: Contents

:description: Exploring Crystal's Features
:source-highlighter: prettify
:keywords: Crystal Language
:imagesdir: ./images


*link:index.html[Index]*


Exploring & Learning Crystal Language via topics that are interesting _(at least to me)_ and hopefully augment it's documentation.  This will be light on theory (lots of that available) and focus on exploring the code and how it works.

Resources that helped are:

* Crystal Lang API Docs - https://crystal-lang.org/api/0.32.1/Fiber.html
* Crystal Lang GitBook - https://crystal-lang.org/reference/guides/concurrency.html
* *Crystal Lang Gitter - https://gitter.im/crystal-lang/crystal* folks instrumental in helping me better undstand and putting these ideas into a context where I could write code that works.

WARNING: This code does not focus on best practices, security or production ready code.  The code is just good enough to demonstrate what is happening.

== Concurrency

By default when crystal code launches a *main thread* is created for the running code, a separate thread is created for the *garbage collector*, and an *Event Loop* to handle IO waits - allowing the main thread to continue while waiting for slow IO calls to finish.

Concurrency happens by `spawn`ing `fiber`s _(light-weight sub-threads within the *main thread*)._  These `fiber`s are scheduled to run within the *main thread* on it's CPU.  Concurrency is a form of *multi-tasking* - quickly switching between tasks on the *main thead.*

Parallelism - _with the appropriate compiler switches_ - allows processes to happen simultaneously on separate CPUs.

=== Spawning Fibers Intro

New Fibers are created using `spawn`.

There two main way to `spawn` threads - we will need both:
- using the block notation
- using the method call notation

=== Spawn Block

A spawn block looks like:

```crystal
# src/concurrency/spawn_block.cr
puts "before spawn"
spawn do
  puts "within spawn"
end
puts "after spawn"

# Fiber.yield
```
Notice when we run:
`crystal run src/concurrency/spawn_block.cr`
We don't see the text _within spawn_

In order to get the main thread to let the Fiber run before ending we need to uncomment the `Fiber.yield` and run again - this tells the main thread to process the fibers on the *main thread* - later we will see there are other actions that trigger the *main thread* to yield to the Fibers.

Spawn block - uses the value given at the time when the Fiber is executed - which can lead to unexpected results. Try the following code:

```crystal
# src/concurrency/spawn_block_unexpected.cr

i = 0
spawn do
  puts i
end

i = 1
spawn do
  puts i
end

# i = 1 when the main thread yields to the fibers!
Fiber.yield
```

Because i = 1 at the time when the fibers execute '1' is printed twice - this is probably not desired in this case.  The solution is to use `Proc`

The solution is to define a proc which will pass the value at the time the `Proc` is called NOT when the `Fiber` is executed.

This code works as expected, but is clumsy looking:
```crystal
# src/concurrency/spawn_proc_block.cr

i = 0
puts_0 = ->(x : Int32) do
  spawn do
    puts(x)
  end
end
puts_0.call(i)

i = 1
puts_1 = ->(x : Int32) do
  spawn do
    puts(x)
  end
end
puts_1.call(i)

Fiber.yield
```

=== Spawn Method Call

Another *much nicer* way to pass the value at the time of call -- not at the time of execution is to use the `spawn` call:

```crystal
# src/concurrency/spawn_call.cr

i = 0
puts i

i = 1
puts i

Fiber.yield
```

This is syntactic sugar (a crystal `macro`) for `proc`-`spawn` technique shown above.  I find this syntax far more attractive and will be used for method calls from now on!

=== Spawning Fibers between Objects

We `spawn` to other objects for concurrent processing.  This next code sample shows how to send both synchronous and asynchronous messages from the *main thread* to objects which will be evaluated within a `Fiber`.

Here is our base `User` object:

```crystal
# src/concurrency/user.cr

class User
  getter channel : Channel(String)
  private getter name : String, email : String

  def initialize(@name, @email)
    @channel = Channel(String).new
  end

  def to_s
    "#{name} <#{email}>"
  end

  def post_message(message : String)
    puts "To: #{to_s} -- #{message}"
  end
end
```

Use concurrently with:
```
# src/concurrency/user_messaging.cr
require "./user"

# USAGE
module UserMessaging
  # create users
  user_1 = User.new(name: "first",  email: "first@example.ch")
  user_2 = User.new(name: "second", email: "second@example.ch")

  # send messages
  puts "REAL-TIME - START"

  # send an async message
  spawn user_1.post_message("ASYNC sent 1st")

  # send a synchronous message
  user_1.post_message("REAL-TIME sent 2nd")
  user_1.post_message("REAL-TIME sent 3rd")

  puts "SWITCH to user_2"
  spawn user_2.post_message("ASYNC sent 4th")
  user_2.post_message("REAL-TIME sent 5th")

  puts "SWITCH back to user_1"
  user_1.post_message("REAL-TIME sent 6th")
  spawn user_1.post_message("ASYNC sent 7th")
  puts "REAL-TIME - DONE"

  # Allow Fibers (async messages) to execute
  Fiber.yield
end
```

Just a reminder, notice how all async messages happen after `Fiber.yield`

*link:index.html[Index]*
