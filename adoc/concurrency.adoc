= Crystal Lang Concurrency
Bill Tihen (Crystal 0.32.1)
Version 0.0.1
:sectnums:
:toc:
:toclevels: 4
:toc-title: Contents

:description: Exploring Crystal's Features
:source-highlighter: coderay
:source-language: ruby
:keywords: Crystal Language
:imagesdir: ./images

*link:index.html[Start Page]*

Exploring & Learning Crystal Language with code examples and augment the documentation.

NOTE: This code does not focus on best practices, security or production ready code. +
The code is just good enough to demonstrate what is happening.

== Concurrency

By default when crystal code launches a *main thread* is created for the running code, a separate thread is created for the *garbage collector*, and an *Event Loop* to handle IO waits - allowing the main thread to continue while waiting for slow IO calls to finish.

Concurrency happens by `spawn`ing `fiber`s _(light-weight sub-threads within the *main thread*)._  These `fiber`s are scheduled to run within the *main thread* on it's CPU.  Concurrency is a form of *multi-tasking* - quickly switching between tasks on the *main thead.*

Parallelism - _with the appropriate compiler switches_ - allows processes to happen simultaneously on separate CPUs.

=== Spawning Fibers Intro

New Fibers are created using `spawn`.

There two main way to `spawn` threads - we will need both:
- using the block notation
- using the method call notation

=== Spawn Block

A spawn block looks like:

.src/concurrency/spawn_block.cr
[source]
----
puts "before spawn"
spawn do
  puts "within spawn"
end
puts "after spawn"

# Fiber.yield
----

Run with:
```
crystal src/concurrency/spawn_block.cr
```

NOTE: We don't see the text *within spawn*

In order to get the main thread to let the Fiber run before ending we need to uncomment the `Fiber.yield` and run again - this tells the main thread to process the fibers on the *main thread* - later we will see there are other actions that trigger the *main thread* to yield to the Fibers.

Spawn block - uses the value given at the time when the Fiber is executed - which can lead to unexpected results. Try the following code:

.src/concurrency/spawn_block_unexpected.cr
[source]
----
i = 0
spawn do
  puts i
end

i = 1
spawn do
  puts i
end

# i = 1 when the main thread yields to the fibers!
Fiber.yield
----

Run with:
```
crystal src/concurrency/spawn_block_unexpected.cr
```

Because i = 1 at the time when the fibers execute '1' is printed twice - this is probably not desired in this case.  The solution is to use `Proc`

The solution is to define a proc which will pass the value at the time the `Proc` is called NOT when the `Fiber` is executed.

This code works as expected, but is clumsy looking:

.src/concurrency/spawn_proc_block.cr
[source]
----
i = 0
puts_0 = ->(x : Int32) do
  spawn do
    puts(x)
  end
end
puts_0.call(i)

i = 1
puts_1 = ->(x : Int32) do
  spawn do
    puts(x)
  end
end
puts_1.call(i)

Fiber.yield
----

Run with:
```
crystal src/concurrency/spawn_proc_block.cr
```

NOTE: now all works well - but lots of code for 2 simple `puts` statements.

=== Spawn Method Call

A *much nicer* way to pass the value at the time of call -- not at the time of execution is to use the `spawn` call:

.src/concurrency/spawn_call.cr
[source]
----
i = 0
puts i

i = 1
puts i

Fiber.yield
----

Run with:
```
crystal src/concurrency/spawn_call.cr
```

This is syntactic sugar (a crystal `macro`) for `proc`-`spawn` technique shown above.  I find this syntax far more attractive and will be used for method calls from now on!

=== Spawning Fibers between Objects

We `spawn` to other objects for concurrent processing.  This next code sample shows how to send both synchronous and asynchronous messages from the *main thread* to objects which will be evaluated within a `Fiber`.

Here is our base `User` object:

.src/concurrency/user.cr
[source]
----
class User
  getter channel : Channel(String)
  private getter name : String, email : String

  def initialize(@name, @email)
    @channel = Channel(String).new
  end

  def to_s
    "#{name} <#{email}>"
  end

  def post_message(message : String)
    puts "To: #{to_s} -- #{message}"
  end
end
----

To use with concurrency:

.src/concurrency/user_messaging.cr
[source]
----
require "./user"     # autoloads the above user.cr file

# USAGE
module UserMessaging
  # create users
  user_1 = User.new(name: "first",  email: "first@example.ch")
  user_2 = User.new(name: "second", email: "second@example.ch")

  # send messages
  puts "REAL-TIME - START"

  # send an async message
  spawn user_1.post_message("ASYNC sent 1st")

  # send a synchronous message
  user_1.post_message("REAL-TIME sent 2nd")
  user_1.post_message("REAL-TIME sent 3rd")

  puts "SWITCH to user_2"
  spawn user_2.post_message("ASYNC sent 4th")
  user_2.post_message("REAL-TIME sent 5th")

  puts "SWITCH back to user_1"
  user_1.post_message("REAL-TIME sent 6th")
  spawn user_1.post_message("ASYNC sent 7th")
  puts "REAL-TIME - DONE"

  # Allow Fibers (async messages) to execute
  Fiber.yield
end
----

Run with:
```
crystal src/concurrency/spawn_call.cr
```

Just a reminder, notice how all async messages happen after `Fiber.yield`

*link:index.html[Start Page]*
